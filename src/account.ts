import { ParsedTransaction } from './steemParser.js';
import { Transaction } from './transactions/index.js';
import cache from './cache.js';
import logger from './logger.js';
import mongo from './mongo.js';
import { AccountDoc } from './mongo.js';

const possibleAccountFields = ['target', 'receiver', 'owner', 'delegate', 'to', 'from', 'account', 'new_account_name'];

export async function upsertAccountsReferencedInTx(tx: ParsedTransaction | Transaction): Promise<void> {
  const usernamesInTx = new Set<string>();

  if (tx.sender && typeof tx.sender === 'string' && tx.sender.trim() !== '') {
    usernamesInTx.add(tx.sender.trim());
  }

  const fieldsToScan = possibleAccountFields || [];

  for (const field of fieldsToScan) {
    if (tx.data && typeof tx.data[field] === 'string' && tx.data[field].trim() !== '') {
      usernamesInTx.add(tx.data[field].trim());
    }
  }
  const uniqueUsernames = Array.from(usernamesInTx);

  for (const username of uniqueUsernames) {
    if (!username) continue;

    logger.debug(`Ensuring account exists: ${username}`);

    let accountFromCache: AccountDoc | undefined | null = cache.accounts[username] as (AccountDoc | undefined | null);
    let accountFromDb: AccountDoc | null = null;

    if (!accountFromCache) {
      try {
        accountFromDb = await mongo.getDb().collection<AccountDoc>('accounts').findOne({ name: username });
        if (accountFromDb) {
          cache.accounts[username] = accountFromDb;
          logger.debug(`Cache updated for ${username} with data from DB.`);
        }
      } catch (dbError) {
        logger.error(`Error fetching account ${username} from DB:`, dbError);
        // Decide if to continue or throw/return error
      }
    }

    // Re-check cache after potential DB fetch and cache update
    const finalAccountState = cache.accounts[username] || accountFromDb;

    if (!finalAccountState) {
      const newAccountData: AccountDoc = {
        name: username,
        created: new Date(),
        tokens: { ECH: 0 }, // Default ECH balance
        nfts: {},
        totalVoteWeight: 0,
        votedWitnesses: []
        // _id will be auto-generated by MongoDB if not provided and name is not the _id
      };

      try {
        // Insert into MongoDB. newAccountData will be mutated with an _id.
        const insertResult = await mongo.getDb().collection<AccountDoc>('accounts').insertOne(newAccountData);
        
        if (!insertResult.insertedId) {
            logger.error(`Failed to insert new account ${username} into DB, no insertedId returned.`);
            throw new Error(`DB insert failed for ${username}`);
        }
        
        // newAccountData now has an _id from MongoDB.
        // Directly update the live cache with the document that's now in the DB.
        cache.accounts[username] = newAccountData;
        logger.debug(`New account ${username} inserted into DB and live cache populated.`);

        // DO NOT call cache.insertOne here as the document is already in the DB.
        // cache.insertOne would add it to a queue for batch insertion, causing a duplicate error.

      } catch (insertError) {
        logger.error(`Failed to insert new account ${username} into DB or update cache:`, insertError);
        // Re-throw or handle as appropriate for your application's error strategy
        throw insertError; 
      }
    } else {
      logger.debug(`Account ${username} already exists in cache or DB.`);
    }
  }
}
