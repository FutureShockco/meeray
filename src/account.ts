import { ParsedTransaction } from './steemParser.js';
import { Transaction } from './transactions/index.js';
import cache from './cache.js';
import logger from './logger.js';
import mongo from './mongo.js';
import { AccountDoc } from './mongo.js';

const possibleAccountFields = ['target', 'receiver', 'owner', 'delegate', 'to', 'from', 'account', 'new_account_name'];

export async function upsertAccountsReferencedInTx(tx: ParsedTransaction | Transaction): Promise<void> {
  const usernamesInTx = new Set<string>();

  if (tx.sender && typeof tx.sender === 'string' && tx.sender.trim() !== '') {
    usernamesInTx.add(tx.sender.trim());
  }

  const fieldsToScan = possibleAccountFields || [];

  for (const field of fieldsToScan) {
    if (tx.data && typeof tx.data[field] === 'string' && tx.data[field].trim() !== '') {
      usernamesInTx.add(tx.data[field].trim());
    }
  }
  const uniqueUsernames = Array.from(usernamesInTx);

  for (const username of uniqueUsernames) {
    if (!username) continue;

    logger.debug(`Ensuring account exists: ${username}`);

    let accountFromCache: AccountDoc | undefined | null = cache.accounts[username] as (AccountDoc | undefined | null);
    let accountFromDb: AccountDoc | null = null;

    if (!accountFromCache) {
      try {
        accountFromDb = await mongo.getDb().collection<AccountDoc>('accounts').findOne({ name: username });
        if (accountFromDb) {
          await new Promise<void>((resolve, reject) => {
            cache.insertOne('accounts', accountFromDb as AccountDoc, (err, success) => {
              if (err) {
                logger.error(`Error updating cache for ${username} from DB:`, err);
                return reject(err);
              }
              logger.debug(`Cache updated/checked for ${username} from DB fetch.`);
              resolve();
            });
          });
        }
      } catch (dbError) {
        logger.error(`Error fetching account ${username} from DB:`, dbError);
        // Decide if to continue or throw/return error
      }
    }

    // Re-check cache after potential DB fetch and cache update
    const finalAccountState = accountFromCache || accountFromDb;

    if (!finalAccountState) {
      const newAccountData: AccountDoc = {
        name: username,
        created: new Date(),
        tokens: { ECH: 0 }, // Default ECH balance
        nfts: {},
        totalVoteWeight: 0,
        votedWitnesses: []
        // _id will be auto-generated by MongoDB if not provided and name is not the _id
      };

      try {
        await mongo.getDb().collection('accounts').insertOne(newAccountData);
        await new Promise<void>((resolve, reject) => {
          cache.insertOne('accounts', newAccountData as AccountDoc, (err, success) => {
            if (err) {
              logger.error(`Error inserting new account ${username} into cache:`, err);
              return reject(err);
            }
            if (!success && success !== undefined) { // Check for explicit false, not undefined
              logger.warn(`[CACHE] insertOne for new account ${username} reported not successful (already exists or no change?).`);
            }
            logger.debug(`New account ${username} inserted into DB and cache.`);
            resolve();
          });
        });
      } catch (insertError) {
        logger.error(`Failed to insert new account ${username} into DB or cache:`, insertError);
        throw insertError;
      }
    } else {
      logger.debug(`Account ${username} already exists in cache or DB.`);
    }
  }
}
