import crypto from 'crypto';
import { toBigInt, toDbString } from '../../utils/bigint.js';
import logger from '../../logger.js';
export enum OrderType {
  LIMIT = 'limit',
  MARKET = 'market',
  // Future: STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT
}

export enum OrderSide {
  BUY = 'buy',
  SELL = 'sell',
}

export enum OrderStatus {
  OPEN = 'open',                // Actively on the book
  PARTIALLY_FILLED = 'partially_filled',
  FILLED = 'filled',
  CANCELLED = 'cancelled',      // Cancelled by user or system
  REJECTED = 'rejected',        // Could not be placed (e.g. insufficient funds, invalid params)
  EXPIRED = 'expired',          // If timeInForce or expiry is implemented
}

// Defines the configuration for a tradable pair
export interface TradingPairData {
  _id: string;                // Unique pair identifier (e.g., BTC-USDT)
  baseAssetSymbol: string;    // Base asset symbol (e.g., BTC)
  quoteAssetSymbol: string;   // Quote asset symbol (e.g., USDT)
  tickSize: string | bigint;          // Minimum price movement
  lotSize: string | bigint;           // Minimum quantity movement
  minNotional: string | bigint;       // Minimum order value in quote asset
  minTradeAmount: string | bigint;    // Minimum trade amount
  maxTradeAmount: string | bigint;    // Maximum trade amount
  status: string;            // Pair status (e.g., 'active', 'paused')
  createdAt: string;         // ISO date string
  lastUpdatedAt?: string;    // ISO date string
}

// Represents an order placed by a user
export interface OrderData {
  _id: string;                    // Unique order ID, generated by the system
  userId: string;                 // Account ID of the user who placed the order
  pairId: string;                 // Reference to TradingPair._id

  baseAssetSymbol: string;        // From TradingPair for easier querying/display
  quoteAssetSymbol: string;       // From TradingPair

  type: OrderType;
  side: OrderSide;
  status: OrderStatus;

  price?: string | bigint;                 // Required for LIMIT orders; the price per unit of baseAsset in terms of quoteAsset
  quantity: string | bigint;               // Desired amount of baseAsset to buy/sell

  filledQuantity: string | bigint;         // Amount of baseAsset that has been filled
  averageFillPrice?: string | bigint;      // Average price at which the order was filled (if partially/fully filled)
  cumulativeQuoteValue?: string | bigint;  // Total value in quoteAsset for filled portion (filledQuantity * averageFillPrice)

  // For MARKET orders, a client might specify how much quote currency they want to spend (for BUY)
  // or how much base currency they want to sell (for SELL, same as quantity).
  // e.g. "Buy BTC with 1000 USDT". If 'quoteOrderQty' is used, 'quantity' might be indicative or calculated.
  quoteOrderQty?: string | bigint;

  createdAt: string;              // ISO Date string
  updatedAt: string;              // ISO Date string of the last status change or fill

  // Optional: For more advanced order types or features
  timeInForce?: 'GTC' | 'IOC' | 'FOK'; // Good-Til-Cancelled, Immediate-Or-Cancel, Fill-Or-Kill
  expiresAt?: string;             // ISO Date string for orders with an expiry
}

// Generate deterministic order ID based on order parameters
function generateOrderId(
  userId: string,
  pairId: string,
  side: OrderSide,
  type: OrderType,
  quantity: bigint,
  price?: bigint,
  transactionId?: string
): string {
  const priceStr = price ? price.toString() : 'market';
  const txId = transactionId || 'no-tx';
  return crypto.createHash('sha256')
    .update(`${userId}_${pairId}_${side}_${type}_${quantity}_${priceStr}_${txId}`)
    .digest('hex')
    .substring(0, 16);
}

// Helper function to create a new order with proper initialization
export function createOrder(data: Partial<OrderData & {
  amount?: bigint | string | number, expirationTimestamp?: bigint | number, tickSize?: bigint | string, lotSize?: bigint | string, transactionId?: string
}>): OrderData {
  // Quantity can be from data.quantity or data.amount (if provided as an alternative)
  const quantityValue = data.quantity !== undefined ? toBigInt(data.quantity) :
    (data.amount !== undefined ? toBigInt(data.amount) : BigInt(0));

  const priceValue = data.price !== undefined ? toBigInt(data.price) : undefined;
  const userId = data.userId || '';
  const pairId = data.pairId || '';
  const side = data.side || OrderSide.BUY;
  const type = data.type || OrderType.LIMIT;

  const orderId = data._id || generateOrderId(userId, pairId, side, type, quantityValue, priceValue, data.transactionId);

  let expiresAtValue: string | undefined = data.expiresAt;
  if (data.expirationTimestamp !== undefined) {
    expiresAtValue = new Date(Number(data.expirationTimestamp) * 1000).toISOString(); // Assuming seconds timestamp
    if (data.expiresAt && data.expiresAt !== expiresAtValue) {
      logger.warn('Both expiresAt (string) and expirationTimestamp (number) provided. Using expirationTimestamp.');
    }
  }

  // Always store price and quantity as padded strings
  const priceValueString = data.price !== undefined ? toDbString(data.price) : undefined;
  const paddedQuantity = toDbString(quantityValue);
  const paddedFilledQuantity = data.filledQuantity !== undefined ? toDbString(data.filledQuantity) : toDbString(0);
  const paddedAverageFillPrice = data.averageFillPrice !== undefined ? toDbString(data.averageFillPrice) : undefined;
  const paddedCumulativeQuoteValue = data.cumulativeQuoteValue !== undefined ? toDbString(data.cumulativeQuoteValue) : undefined;
  const paddedQuoteOrderQty = data.quoteOrderQty !== undefined ? toDbString(data.quoteOrderQty) : undefined;

  return {
    _id: orderId,
    userId: data.userId || '',
    pairId: data.pairId || '',
    baseAssetSymbol: data.baseAssetSymbol || '',
    quoteAssetSymbol: data.quoteAssetSymbol || '',
    side: data.side || OrderSide.BUY,
    type: data.type || OrderType.LIMIT,
    price: priceValueString,
    quantity: paddedQuantity,
    filledQuantity: paddedFilledQuantity,
    status: data.status || OrderStatus.OPEN,
    averageFillPrice: paddedAverageFillPrice,
    cumulativeQuoteValue: paddedCumulativeQuoteValue,
    quoteOrderQty: paddedQuoteOrderQty,
    createdAt: data.createdAt || new Date().toISOString(),
    updatedAt: data.updatedAt || new Date().toISOString(),
    timeInForce: data.timeInForce,
    expiresAt: expiresAtValue,
  };
}

// Utility to check tick/lot size alignment
export function isAlignedToTickSize(value: bigint, tickSize: bigint): boolean {
  return tickSize > 0n ? value % tickSize === 0n : true;
}
export function isAlignedToLotSize(value: bigint, lotSize: bigint): boolean {
  return lotSize > 0n ? value % lotSize === 0n : true;
}

// Represents an executed trade between two orders
export interface TradeData {
  _id: string;                    // Unique trade ID
  pairId: string;                 // Reference to TradingPairData._id

  baseAssetSymbol: string;
  quoteAssetSymbol: string;

  makerOrderId: string;           // ID of the order that was resting on the book (maker)
  takerOrderId: string;           // ID of the order that matched with the maker (taker)

  price: string | bigint;                  // Price at which the trade was executed
  quantity: string | bigint;               // Amount of baseAsset traded

  buyerUserId: string;            // User ID of the buyer
  sellerUserId: string;           // User ID of the seller

  timestamp: string;              // ISO Date string of when the trade occurred

  isMakerBuyer: boolean;          // True if the buyer was the maker, false if taker was buyer
  // (Alternatively, could deduce from makerOrderId's side)

  // Fees
  feeAmount?: string | bigint;             // Total fee paid for this trade
  feeCurrency?: string;           // Symbol of the currency the fee was paid in (could be base, quote, or a native token)
  // individual fees for maker/taker can also be stored if they differ
  makerFee?: string | bigint;
  takerFee?: string | bigint;
  total: string | bigint;                  // Total in quote asset (amount * price)
  maker: string;                  // User ID of the maker
  taker: string;                  // User ID of the taker
}

// Represents a single price level in the order book
export interface OrderBookLevelData {
  price: string | bigint;
  quantity: string | bigint;               // Total quantity of baseAsset available at this price
  orderCount?: number;            // Optional: number of individual orders at this level
}

// Represents a snapshot of the order book for a given pair
export interface OrderBookSnapshotData {
  pairId: string;                 // Reference to TradingPairData._id
  timestamp: string;              // ISO Date string of when the snapshot was taken
  lastUpdateId?: number;          // Sequence number for diff updates (like Binance API)
  bids: OrderBookLevelData[];         // Buy orders, sorted descending by price (highest bid first)
  asks: OrderBookLevelData[];         // Sell orders, sorted ascending by price (lowest ask first)
}

// For operations that create/update orders/pairs
export interface MarketCreatePairData {
  baseAssetSymbol: string;
  quoteAssetSymbol: string;
  tickSize: string | bigint;             // Changed from number to bigint
  lotSize: string | bigint;              // Changed from number to bigint
  minNotional: string | bigint;          // Changed from number to bigint
  initialStatus?: string;       // Default to 'TRADING' or 'PRE_TRADE'
  minTradeAmount?: string | bigint;      // Minimum trade amount in quote asset
  maxTradeAmount?: string | bigint;      // Maximum trade amount in quote asset
}

export interface MarketPlaceOrderData {
  pairId: string;
  type: OrderType;
  side: OrderSide;
  price?: string | bigint;              // Required for LIMIT
  quantity: string | bigint;
  quoteOrderQty?: string | bigint;      // For MARKET BUY by quote amount
  timeInForce?: 'GTC' | 'IOC' | 'FOK';
  expiresAt?: string;          // ISO string, matches Order.expiresAt
  expirationTimestamp?: number; // Unix timestamp in seconds
}

export interface MarketCancelOrderData {
  orderId: string;
  pairId: string; // Useful for routing/sharding if books are managed per pair
}

// ===== HYBRID TRADING INTERFACES =====
// Modern unified trading system combining AMM and Orderbook liquidity

// Hybrid trading transaction data
export interface HybridTradeData {
  tokenIn: string;                   // Token being sold (format: symbol)
  tokenOut: string;                  // Token being bought (format: symbol)
  amountIn: string | bigint;         // Amount of tokenIn to trade

  // Price Control (choose one approach):
  price?: string | bigint;           // LIMIT ORDER: Specific price to execute at (overrides slippage protection)
  // When specified, creates limit orders instead of market orders

  // Slippage Protection (used when price is not specified):
  maxSlippagePercent?: number;       // RECOMMENDED: Maximum allowed slippage percentage (e.g., 2.0 for 2%)
  // This automatically calculates minAmountOut based on current market prices

  minAmountOut?: string | bigint;    // ADVANCED: Exact minimum amount of tokenOut expected
  // Only use if you need precise control and know token decimals
  // Note: Cannot be used together with maxSlippagePercent

  routes?: HybridRoute[];            // Optional: Specific routes to use (auto-route if not provided)
}

// Route information for hybrid trades
export interface HybridRoute {
  type: 'AMM' | 'ORDERBOOK';
  allocation: number;                // Percentage of trade (0-100)
  details: AMMRouteDetails | OrderbookRouteDetails;
}

export interface AMMRouteDetails {
  poolId?: string;                   // For single pool swap
  hops?: Array<{                     // For multi-hop AMM swaps
    poolId: string;
    tokenIn: string;
    tokenOut: string;
  }>;
}

export interface OrderbookRouteDetails {
  pairId: string;                    // Trading pair ID
  side: OrderSide;                   // BUY or SELL
  orderType?: OrderType;             // LIMIT or MARKET (default MARKET for hybrid)
  price?: string | bigint;           // For LIMIT orders - the specific price to execute at
}

// Liquidity source information
export interface LiquiditySource {
  type: 'AMM' | 'ORDERBOOK';
  id: string;                        // Pool ID or Pair ID
  tokenA: string;
  tokenB: string;
  reserveA?: string | bigint;        // For AMM pools
  reserveB?: string | bigint;        // For AMM pools
  bestBid?: string | bigint;         // For orderbooks
  bestAsk?: string | bigint;         // For orderbooks
  bidDepth?: string | bigint;        // Available liquidity on bid side
  askDepth?: string | bigint;        // Available liquidity on ask side
  hasLiquidity?: boolean;            // Whether this source has actual liquidity to trade against
}

// Quote response for hybrid trades
export interface HybridQuote {
  amountIn: string;
  amountOut: string;
  amountOutFormatted: string;
  priceImpact: number;
  priceImpactFormatted: string;
  routes: Array<{
    type: 'AMM' | 'ORDERBOOK';
    allocation: number;
    amountIn: string;
    amountOut: string;
    priceImpact: number;
    details: any;
  }>;
  warning?: string;                  // Any warnings about the quote
}

// Result of hybrid trade execution
export interface HybridTradeResult {
  success: boolean;
  actualAmountOut: string;
  actualPriceImpact: number;
  executedRoutes: Array<{
    type: 'AMM' | 'ORDERBOOK';
    amountIn: string;
    amountOut: string;
    transactionId?: string;
  }>;
  totalGasUsed?: string;
  error?: string;
}